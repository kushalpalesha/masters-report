\chapter{What is policy-agnostic programming?\label{chap:PAP}}

Before we talk about policy-agnostic programming, we first need to give an
introduction to the domain it belongs to i.e. information flow security.

\section{A brief overview of information flow security}

Information flow security is a security mechanism that consists of information flow
policies and information flow controls to detect and prevent leaking of sensitive
data by an application. Information flow policies here are the policies that define
where sensitive data can flow. Information flow controls are the mechanisms that
enforce them.

When designing a system with information flow security, sensitive data needs to
be identified and corresponding information flow policies need to be defined.
Smith~\cite{PrincInfoSec} talks about basic principles of information flow security
that we mention here in brief. We assign \textit{security} labels to variables
according to the level of security they are classified into. The most basic labels
are L for low security or public information and H for high security or private
information; goal is to prevent improper leaks of information in H variables to
L variables. The flow of data from an L variable into an H variable is legal.

In information flow security, the leak can be in terms of an \textit{explicit flow}
or an \textit{implicit flow}. \\
The following is an example of an \textit{explicit flow} where there is a direct
flow of data from an H variable to an L variable.
\indent
\texttt{public\textsubscript{L} = confidential\textsubscript{H}} \\
\noindent \\
The code-snippet below is an example of an \textit{implicit flow}. \\
\indent
	\texttt{if (confidential\textsubscript{H} \% 2)  == 0 \\ \indent \indent
		public\textsubscript{L} = 0 \\ \indent
	else \\ \indent \indent
		public\textsubscript{L} = 1} \\
\noindent Although it may not seem obvious that there is a leak of sensitive data
in this example, the last bit of the H variable (\texttt{confidential\textsubscript{H}})
is being copied into the L variable (\texttt{public\textsubscript{L}}). Any case
where there is a branching statement that depends on an H variable has a potential
data leak in terms of an \textit{implicit flow}.

An important property in information flow security is noninterference. Smith~\cite{PrincInfoSec},
defines a program satisfying noninterference as:

\begin{quotation}
	\noindent Program $c$ satisfies noninterference if, for
	any memories $\mu$ and $v$ that agree on L variables, the memories produced by
	running $c$ on $\mu$ and on $v$ also agree on L variables (provided that both runs
	terminate successfully).
\end{quotation}
It is a formalization of the idea that a program should not leak
information about H (private) variables through L (public) variables. All systems
that provide information flow analysis need to prove noninterference. Although
strict noninterference is not desired since a real world system may need to change
labels or declassify (downgrade level of a variable) variables at runtime.

Information flow security is used to ensure \textit{confidentiality} and \textit{integrity}
of data. Our solution will mostly focus on \textit{confidentiality} but here we would
briefly like to define the two in the context of information flow security. \textit{Confidentiality}
as we have described above ensures that there is no unwanted flow of information
from H variables into L variables. For example, you wouldn't want to allow the
flow of data from a variable that contains credit card information into a variable
that is meant to store payment amount. \textit{Integrity} introduces the concepts of
tainted and untainted variables. Here the aim is to not allow the flow of information
of tainted variables into untainted variables. Here tainted variables are any
variables that contain information received from an external source for example
network or user input. For example, data in a tainted variable needs to be sanitized
before it can be used as a parameter in an SQL query or as part of a string that
is given as input to the \texttt{eval} function. \texttt{eval} is a function that
is available in Javascript that takes a string (assumed to be code) as input and
executes it.

\subsection{Language based information flow security \label{subsec:langinfo}}
There have been several approaches that researchers have tried to deal with the
problem of information flow security primarily categorized into static and dynamic
analysis~\cite{Russo, Chlipala}. In recent years however, a lot of the research has
been focussed on language-based approaches with the objective of making information
flow security a part of the programming language used for development. These are
mostly extensions to existing programming languages that provide constructs to define
labels and policies and has a mechanism to check those policies. As Sablefeld and
Myers~\cite{LangInfo} discuss, the use of type systems for information flow analysis
presents a promising approach to get a practical implementation of information
flow control. Here, every expression has a security type with two parts:
an ordinary type and a label that describes how the value may be used. It is the
job of the compiler to perform type checking; whenever a program containing labelled
types is read, the compiler also makes sure that there will be no illegal flow of
information at run-time. The authors call such a type system that enforces information
flow policies a \textit{security-type system}.

An example of a language with a security-type system is Jif (Java + information flow)
\cite{jifurl} that extends Java with information flow control and access control support
that are enforced at compile-time and run-time. It is based on the JFlow
language~\cite{Jflow}, which is the first usable programming model that provided
static information flow analysis.

The programming model introduced with Jif provides a robust set of features along
with the ability to specify information flow policies that are enforced by the Jif
compiler, but it is still not adopted in many practical, real-world systems. This is largely
due to the fact that a programmer must still have policy checking logic all over
the program whenever a sensitive value is used. When access to a sensitive value
is forbidden by a policy and the programmer has not handled such cases, the program
is likely to behave in an unexpected manner or get stuck. As Yang puts it in her
thesis~\cite{YangPhd}, handling all cases where sensitive variables are used leads
to ``programmer burden from policy spaghetti''. That is, using a system like Jif
results in policy checking logic scattered throughout the code. This leads to code
that is difficult to maintain and prone to human error. Another problem is realized
when these policies need to be changed, which would mean changes everywhere the
sensitive variable is used.

\section{The policy-agnostic programming model}
In an attempt to make the implementation of information flow security more flexible,
Yang et al~\cite{Jeeves} introduced the policy-agnostic programming (PAP) model.
PAP is an approach where the developer only needs to focus on writing core functionality
without the additional burden of thinking about data privacy constraints on sensitive
values.

PAP is introduced using Jeeves, a domain specific language that provides constructs
to define sensitive labels, policies and to assign labels to variables. In Jeeves,
sensitive data has two views associated with it, a high confidentiality view and a
low confidentiality view. What view of the sensitive data is revealed to a particular
output channel depends on the ``context'' of the channel and the policy associated with the
sensitive data. ``Context'' here is an object that contains relevant information
that a policy may refer to. This can vary depending on the application.~\cite{FacetedJeeves}
provides an example of a context object for a health database application:\\
\indent\texttt{HealthContext \{viewer: User, time: Date\}}\\
Here, the policies attached to sensitive variables will be resolved based on the
user who is trying to access a health record while time allows certain policies
to define expiration and activation times for visibility.
The goal of PAP is that you define all policies on sensitive variables
when the variables themselves are defined. After this, everywhere the sensitive variables
are used, the language runtime is responsible for enforcing and checking the policies
associated with them.

The initial implementation of Jeeves involved symbolic evaluation and constraint
solving to produce outputs adhering to the policies associated with sensitive data.
This approach had limitations in terms of implementation feasibility and expressiveness,
which is why it was later extended with faceted values~\cite{FacetedJeeves}.
The faceted execution of policy-agnostic programs is based on work by Austin and
Flanagan~\cite{Faceted}. In fact, we will be extending the implementation done
in~\cite{Faceted} to implement the policy-agnostic programming model.

\textbf{To be continued...}
