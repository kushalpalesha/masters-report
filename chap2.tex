\chapter{What is policy-agnostic programming?\label{chap:PAP}}

Before we talk about policy-agnostic programming, we first need to give an
introduction to the domain it belongs to i.e. information flow security.

\section{A brief overview of information flow security}

Information flow security is a security mechanism that consists of information flow
policies and information flow controls to detect and prevent leaking of sensitive
data by an application. Information flow policies here are the policies that define
where sensitive data can flow. Information flow controls are the mechanisms that
enforce them.

When designing a system with information flow security, sensitive data needs to
be identified and corresponding information flow policies need to be defined. In
\cite{PrincInfoSec}, Smith talks about basic principles of information flow security
that we mention here in brief. We assign \textit{security} labels to variables
according to the level of security they are classified into. The most basic labels
are L i.e. low security or public information and H i.e. high security or private
information and the goal is to prevent improper leaking of information in H variables.

In information flow security, the
objective is to prevent any unwanted leak of sensitive data. The leak can be in
terms of an \textit{explicit flow}: \\ \indent
\texttt{public\textsubscript{L} = confidential\textsubscript{H}} \\
\noindent or an \textit{implicit flow}: \\ The code-snippet below
copies the last bit of \texttt{confidential\textsubscript{H}} to \texttt{public\textsubscript{L}}: \\
\indent
	\texttt{if (confidential\textsubscript{H} \% 2)  == 0 \\ \indent \indent
		public\textsubscript{L} = 0 \\ \indent
	else \\ \indent \indent
		public\textsubscript{L} = 1} \\
The flow of data from an L variable into an H variable on the other hand is considered
legal.

An important property in information flow security is noninterference. Smith~\cite{PrincInfoSec},
defines a program satisfying noninterference as: \begin{quotation}
	\noindent Program $c$ satisfies noninterference if, for
	any memories $\mu$ and $v$ that agree on L variables, the memories produced by
	running $c$ on $\mu$ and on $v$ also agree on L variables (provided that both runs
	terminate successfully).
\end{quotation} It is a formalization of the idea that a program should not leak
information about H (private) variables through L (public) variables. All systems
that provide information flow analysis need to prove noninterference. Although
strict noninterference is not desired since a real world system may need to change
labels or declassify (downgrade level of a variable) variables at runtime.

Information flow security is used to ensure \textit{confidentiality} and \textit{integrity}
of data. Our solution will mostly focus on \textit{confidentiality} but here we would
briefly like to define the two in the context of information flow security. \textit{Confidentiality}
as we have described above ensures that there is no unwanted flow of information
from H variables into L variables. \textit{Integrity} introduces the concepts of
tainted and untainted variables. Here the aim is to not allow the flow of information
of tainted variables into untainted variables. Here tainted variables are any
variables that contain information received from an external source for example
network or user input.

\subsection{Language based information flow security \label{subsec:langinfo}}
There have been several approaches that researchers have tried to deal with the
problem of information flow security primarily categorized into static and dynamic
analysis~\cite{Russo, Chlipala}. In recent years however, a lot of the research has
been focussed on language-based approaches with the objective of making information
flow security a part of the programming language used for development. These are
mostly extensions to existing programming languages that provide constructs to define
labels and policies and has a mechanism to check those policies. As Sablefeld and
Myers discuss in their article~\cite{LangInfo} the use of type systems for information
flow analysis presenting a promising approach to get a practical implementation of
information flow control. Here, every expression has a security type with two parts:
an ordinary type and a label that describes how the value may be used. It is the
job of the compiler to perform type checking; whenever a program containing labelled
types is read, while type checking the compiler also makes sure that there will
be no illegal flow of information at run-time. The authors call such a type system
that enforces information flow policies a \textit{security-type system}.

An example of a language with a security-type system is Jif(Java + information flow)
\cite{jifurl} that extends Java with information flow control and access control support
that are enforced at compile-time and run-time. It is based on the JFlow language
\cite{Jflow} which is the first usable programming model that provided static
information flow analysis.

The programming model introduced with Jif provides a robust set of features along
with the ability to specify information flow policies which are enforced by the Jif
compiler, but it is still not adopted in practical real world systems. This is largely
due to the fact that a programmer is still needed to have policy checking logic
all over the program whenever a sensitive value is used. When access to a sensitive
value is forbidden by a policy and the programmer has not handled such cases, the
program is likely to behave in an unexpected manner or get stuck. As Yang puts it
in her thesis~\cite{YangPhd}, handling all cases where sensitive variables are used
leads to ``programmer burden from policy spaghetti''. That is, using a system like
Jif results in policy checking logic scattered throughout the code. This leads to
code that is difficult to maintain and prone to human error. Another problem is
realized when these policies need to be changed which would mean changes everywhere
the sensitive variable is used.

\section{The policy-agnostic programming model}
In an attempt to make the implementation of information flow security more flexible,
Yang et al~\cite{Jeeves} introduced the policy-agnostic programming (PAP) model.
PAP is an approach where the developer only needs to focus on writing core functionality
without the additional burden of thinking about data privacy constraints on sensitive
values.

PAP is introduced using Jeeves, a domain specific language that provides constructs
to define sensitive labels, policies and to assign labels to variables. In Jeeves,
sensitive data has two views associated with it, a high confidentiality view and a
low confidentiality view. What view of the sensitive data is revealed to a particular
output channel depends on the output context and the policy associated with the
sensitive data. The goal of PAP is that you define all policies on sensitive variables
when the variables themselves are defined. After this, everywhere the sensitive variables
are used, the language runtime is responsible for enforcing and checking the policies
associated with them.

The initial implementation of Jeeves involved symbolic evaluation and constraint
solving to produce outputs adhering to the policies associated with sensitive data.
This approach had limitations in terms of implementation feasibility and expressiveness
which is why it was later extended with faceted values~\cite{FacetedJeeves}.
The faceted execution of policy-agnostic programs is based on work by Austin and
Flanagan~\cite{Faceted}. In fact, we will be extending the implementation done
in~\cite{Faceted} to implement the policy-agnostic programming model.

\textbf{To be continued...}
